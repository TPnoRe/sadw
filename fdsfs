
-- ‡∏£‡∏∞‡∏ö‡∏ö‡∏°‡∏≤‡πÇ‡∏Ñ‡∏£‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô
repeat task.wait() until game:IsLoaded()

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

task.wait(2)

local function isTeleportUIVisible()
    local tpUI = LocalPlayer.PlayerGui:FindFirstChild("TeleportUI")
    if not tpUI then return false end
    local ok, visible = pcall(function() return tpUI.Enabled end)
    return ok and visible
end

local function isPlayerInValidState()
    local character = LocalPlayer.Character
    if not character then return false end
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end
    return true
end

local maxWaitTime = 0
local maxWait = 20
repeat
    task.wait(0.2)
    maxWaitTime = maxWaitTime + 0.2
until (not isTeleportUIVisible() and isPlayerInValidState()) or maxWaitTime > maxWait

if maxWaitTime > maxWait and not isPlayerInValidState() then
    task.wait(3)
end

task.wait(1)

local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local oldLogWarn = logwarn or warn
local function filteredWarn(...)
    local msg = tostring(...)
    if not (msg:find("ImageLabel") or msg:find("not a valid member") or msg:find("is not a valid member")) then
        oldLogWarn(...)
    end
end
if logwarn then logwarn = filteredWarn end
warn = filteredWarn

local RS = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local CONFIG_FOLDER = "ALSHalloweenEvent"
local MACRO_FOLDER = CONFIG_FOLDER .. "/macros"
if not isfolder(CONFIG_FOLDER) then makefolder(CONFIG_FOLDER) end
if not isfolder(MACRO_FOLDER) then makefolder(MACRO_FOLDER) end

local STATE_FILE = MACRO_FOLDER .. "/playback_state.json"
local SETTINGS_FILE = MACRO_FOLDER .. "/settings.json"

local Macros = {}
local CurrentMacro = nil
local recording = false
local playing = false
local macroData = {}
local StepDelay = 0
local resumeFromStep = 0

local StatusText = "Idle"
local ActionText = ""
local UnitText = ""
local WaitingText = ""
local CurrentStep = 0
local TotalSteps = 0

local TowerInfoCache = {}
local RemoteCache = {}

local lastCash = 0
local cashHistory = {}
local MAX_CASH_HISTORY = 30

local StatusLabel, StepLabel, ActionLabel, UnitLabel, WaitingLabel

local seamlessMode = false
local autoReplayOnRestart = false

-- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏Å‡∏¥‡∏•
local abilityDataCache = {}

local function loadSettings()
    local settings = {
        playMacroEnabled = false,
        selectedMacro = nil,
        macroMaps = {},
        seamlessMode = false,
        autoReplayOnRestart = false,
        stepDelay = 0
    }
    pcall(function()
        if isfile(SETTINGS_FILE) then
            local data = HttpService:JSONDecode(readfile(SETTINGS_FILE))
            if type(data) == "table" then
                settings = data
            end
        end
    end)
    return settings
end

local function saveSettings()
    pcall(function()
        local settings = {
            playMacroEnabled = playing,
            selectedMacro = CurrentMacro,
            macroMaps = getgenv().MacroMaps or {},
            seamlessMode = seamlessMode,
            autoReplayOnRestart = autoReplayOnRestart,
            stepDelay = StepDelay
        }
        writefile(SETTINGS_FILE, HttpService:JSONEncode(settings))
    end)
end

local function notify(title, content, duration)
    WindUI:Notify({
        Title = title or "Macro",
        Content = content or "",
        Duration = duration or 3,
    })
end

local function cacheTowerInfo()
    if next(TowerInfoCache) then return end
    local towerInfoPath = RS:WaitForChild("Modules"):WaitForChild("TowerInfo")
    for _, mod in pairs(towerInfoPath:GetChildren()) do
        if mod:IsA("ModuleScript") then
            local ok, data = pcall(function() return require(mod) end)
            if ok then TowerInfoCache[mod.Name] = data end
        end
    end
    print("[Macro] Cached tower info for " .. tostring(#TowerInfoCache) .. " towers")
end

local function cacheRemotes()
    if next(RemoteCache) then return end
    for _, v in pairs(RS:GetDescendants()) do
        if v:IsA("RemoteEvent") or v:IsA("RemoteFunction") then
            RemoteCache[v.Name:lower()] = v
        end
    end
    print("[Macro] Cached " .. tostring(#RemoteCache) .. " remotes")
end

task.spawn(function()
    task.wait(2)
    cacheTowerInfo()
    cacheRemotes()
end)

local cashTrackingActive = false
local function trackCash()
    if cashTrackingActive then return end
    cashTrackingActive = true
    
    task.spawn(function()
        while true do
            RunService.Heartbeat:Wait()
            
            local currentCash = 0
            pcall(function()
                currentCash = LocalPlayer.Cash.Value
            end)
            
            if lastCash > 0 and currentCash < lastCash then
                local decrease = lastCash - currentCash
                table.insert(cashHistory, 1, {
                    time = tick(),
                    decrease = decrease,
                    before = lastCash,
                    after = currentCash
                })
                
                if #cashHistory > MAX_CASH_HISTORY then
                    table.remove(cashHistory, #cashHistory)
                end
            end
            
            lastCash = currentCash
        end
    end)
end

trackCash()

local function getRecentCashDecrease(withinSeconds)
    withinSeconds = withinSeconds or 1
    local now = tick()
    for _, entry in ipairs(cashHistory) do
        if (now - entry.time) <= withinSeconds then
            return entry.decrease
        end
    end
    return 0
end

local function getPlaceCost(towerName)
    cacheTowerInfo()
    if not TowerInfoCache[towerName] then return 0 end
    if TowerInfoCache[towerName][0] then
        return TowerInfoCache[towerName][0].Cost or 0
    end
    return 0
end

local function loadMacros()
    Macros = {}
    if not isfolder(MACRO_FOLDER) then return end
    for _, file in pairs(listfiles(MACRO_FOLDER)) do
        if file:sub(-5) == ".json" then
            local ok, data = pcall(function() return HttpService:JSONDecode(readfile(file)) end)
            if ok then Macros[file:match("([^/\\]+)%.json$")] = data end
        end
    end
end

local function saveMacro(name, data)
    local success, err = pcall(function()
        writefile(MACRO_FOLDER .. "/" .. name .. ".json", HttpService:JSONEncode(data))
        Macros[name] = data
    end)
    if not success then
        warn("[Macro] Failed to save:", err)
    end
    return success
end

local function savePlaybackState(macroName, currentStep)
    pcall(function()
        local state = {
            macro = macroName,
            step = currentStep,
            timestamp = tick()
        }
        writefile(STATE_FILE, HttpService:JSONEncode(state))
    end)
end

local function loadPlaybackState()
    local state = nil
    pcall(function()
        if isfile(STATE_FILE) then
            state = HttpService:JSONDecode(readfile(STATE_FILE))
        end
    end)
    return state
end

local function clearPlaybackState()
    pcall(function()
        if isfile(STATE_FILE) then
            delfile(STATE_FILE)
        end
    end)
end

local function isAutoUpgradeClone(towerName)
    local autoUpgradeClones = {
        "NarutoBaryonClone",
        "WukongClone",
    }
    
    for _, cloneName in ipairs(autoUpgradeClones) do
        if towerName == cloneName then
            return true
        end
    end
    
    return false
end

local function getMacroNames()
    local names = {}
    for name in pairs(Macros) do table.insert(names, name) end
    table.sort(names)
    return names
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥‡πÅ‡∏ö‡∏ö‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
local function executeAnyAction(action)
    if not action.RemoteName then return true end
    
    local remote = RemoteCache[action.RemoteName:lower()]
    if not remote then
        print("[Macro] Remote not found:", action.RemoteName)
        return true
    end
    
    -- ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° arguments
    local executeArgs = {}
    if action.Args then
        for i, arg in ipairs(action.Args) do
            if type(arg) == "table" and #arg >= 12 then
                -- ‡πÅ‡∏õ‡∏•‡∏á‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô CFrame
                executeArgs[i] = CFrame.new(unpack(arg))
            else
                executeArgs[i] = arg
            end
        end
    end
    
    -- ‡∏£‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥
    if remote:IsA("RemoteFunction") then
        remote:InvokeServer(unpack(executeArgs))
    else
        remote:FireServer(unpack(executeArgs))
    end
    
    print("[Macro] ‚úì Executed:", action.ActionType, "-", action.RemoteName)
    return true
end

local Window = WindUI:CreateWindow({
    Title = "Macro System",
    Author = "ALS - Macro",
    Folder = "ALS-Macro",
    NewElements = true,
    HideSearchBar = false,
    OpenButton = {
        Title = "Macro System",
        CornerRadius = UDim.new(1, 0),
        StrokeThickness = 1,
        Enabled = true,
        Draggable = true,
        OnlyMobile = false,
        Color = ColorSequence.new(Color3.fromRGB(48, 255, 106), Color3.fromRGB(231, 255, 47)),
    },
})

local MainSection = Window:Section({
    Title = "Main",
    Icon = "play",
})

local MapsSection = Window:Section({
    Title = "Macro Maps",
    Icon = "map",
})

local SettingsSection = Window:Section({
    Title = "Settings",
    Icon = "settings",
})

local Tabs = {
    Main = MainSection:Tab({ Title = "Controls", Icon = "play" }),
    Maps = MapsSection:Tab({ Title = "Map Assignment", Icon = "map" }),
    Settings = SettingsSection:Tab({ Title = "Settings", Icon = "settings" }),
}

loadMacros()

local savedSettings = loadSettings()
getgenv().MacroMaps = savedSettings.macroMaps or {}
seamlessMode = savedSettings.seamlessMode or false
autoReplayOnRestart = savedSettings.autoReplayOnRestart or false
StepDelay = savedSettings.stepDelay or 0
local MapData = nil
pcall(function()
    local mapDataModule = RS:FindFirstChild("Modules") and RS.Modules:FindFirstChild("MapData")
    if mapDataModule and mapDataModule:IsA("ModuleScript") then
        MapData = require(mapDataModule)
    end
end)

local function getMapsByGamemode(gamemode)
    if not MapData then return {} end
    if gamemode == "ElementalCaverns" then return {"Light","Nature","Fire","Dark","Water"} end
    local maps = {}
    for mapName, mapInfo in pairs(MapData) do
        if mapInfo.Type and type(mapInfo.Type) == "table" then
            for _, mapType in ipairs(mapInfo.Type) do
                if mapType == gamemode then
                    table.insert(maps, mapName)
                    break
                end
            end
        end
    end
    table.sort(maps)
    return maps
end

local lastStatusUpdate = 0
local updateStatus
updateStatus = function()
    local now = tick()
    if now - lastStatusUpdate < 0.03 then return end
    lastStatusUpdate = now
    
    pcall(function()
        if StatusLabel then StatusLabel:SetTitle("Status: " .. StatusText) end
        if StepLabel then StepLabel:SetTitle("üìù Step: " .. CurrentStep .. "/" .. TotalSteps) end
        if ActionLabel then ActionLabel:SetTitle("‚ö° Action: " .. ActionText) end
        if UnitLabel then UnitLabel:SetTitle("üóº Unit: " .. UnitText) end
        if WaitingLabel then WaitingLabel:SetTitle("‚è≥ Waiting: " .. WaitingText) end
    end)
end

Tabs.Main:Paragraph({
    Title = "üé¨ Macro System",
    Desc = "‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏∏‡∏Å‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥"
})

Tabs.Main:Space()
Tabs.Main:Divider()
Tabs.Main:Space()

Tabs.Main:Paragraph({
    Title = "üìù Macro Management",
    Desc = "Create, select, and manage your macros"
})

Tabs.Main:Space()

local macroDropdown = Tabs.Main:Dropdown({
    Flag = "MacroSelect",
    Title = "Select Macro",
    Values = getMacroNames(),
    Callback = function(v)
        CurrentMacro = v
        if v and Macros[v] then
            macroData = Macros[v]
            TotalSteps = #macroData
            notify("Macro Selected", v .. " (" .. #macroData .. " steps)", 3)
            updateStatus()
            saveSettings()
        end
    end,
    Searchable = true,
})

if savedSettings.selectedMacro and Macros[savedSettings.selectedMacro] then
    task.spawn(function()
        task.wait(0.3)
        pcall(function()
            macroDropdown:Select(savedSettings.selectedMacro)
            CurrentMacro = savedSettings.selectedMacro
            macroData = Macros[CurrentMacro]
            TotalSteps = #macroData
            updateStatus()
        end)
    end)
end

Tabs.Main:Space()

Tabs.Main:Input({
    Flag = "MacroName",
    Title = "Create New Macro",
    Placeholder = "Enter macro name",
    Callback = function(v)
        if v and v ~= "" and not Macros[v] then
            print("[Macro] Creating macro: " .. v)
            
            saveMacro(v, {})
            Macros[v] = {}
            CurrentMacro = v
            macroData = {}
            TotalSteps = 0
            
            local newMacroNames = getMacroNames()
            print("[Macro] New macro list:", table.concat(newMacroNames, ", "))
            
            if macroDropdown then
                print("[Macro] Refreshing dropdown with " .. #newMacroNames .. " macros")
                
                task.spawn(function()
                    local refreshSuccess = pcall(function()
                        macroDropdown:Refresh(newMacroNames)
                    end)
                    
                    if refreshSuccess then
                        print("[Macro] Dropdown refreshed successfully")
                        task.wait(0.3)
                        
                        local selectSuccess = pcall(function()
                            macroDropdown:Select(v)
                        end)
                        
                        if selectSuccess then
                            print("[Macro] ‚úì Macro '" .. v .. "' selected in dropdown")
                        else
                            print("[Macro] ‚úó Failed to select macro in dropdown")
                        end
                    else
                        print("[Macro] ‚úó Failed to refresh dropdown")
                    end
                    
                    updateStatus()
                    notify("Macro Created", v .. " - Ready to record!", 3)
                end)
            else
                print("[Macro] ‚úó macroDropdown is nil!")
                notify("Macro Created", v .. " - Ready to record!", 3)
            end
            
            saveSettings()
        elseif Macros[v] then
            notify("Error", "Macro '" .. v .. "' already exists!", 3)
        end
    end
})

Tabs.Main:Space()
Tabs.Main:Divider()
Tabs.Main:Space()

Tabs.Main:Paragraph({
    Title = "üéÆ Recording & Playback",
    Desc = "Control macro recording and playback"
})

Tabs.Main:Space()

Tabs.Main:Toggle({
    Flag = "RecordMacro",
    Title = "üî¥ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥",
    Default = false,
    Callback = function(v)
        recording = v
        if v then
            if not CurrentMacro then
                notify("‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏°‡∏≤‡πÇ‡∏Ñ‡∏£‡∏Å‡πà‡∏≠‡∏ô", "‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏°‡∏≤‡πÇ‡∏Ñ‡∏£‡∏Å‡πà‡∏≠‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å", 3)
                recording = false
                return
            end
            macroData = {}
            StatusText = "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å..."
            getgenv().TowerPlaceCounts = {}
            cashHistory = {}
            abilityDataCache = {}
            CurrentStep = 0
            TotalSteps = 0
            ActionText = ""
            UnitText = ""
            WaitingText = ""
            updateStatus()
            notify("‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å", "‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ó‡∏∏‡∏Å‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì", 3)
        else
            StatusText = "Idle"
            ActionText = ""
            UnitText = ""
            WaitingText = ""
            updateStatus()
            if CurrentMacro and #macroData > 0 then
                local success = saveMacro(CurrentMacro, macroData)
                if success then
                    notify("‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏™‡∏£‡πá‡∏à", "‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å " .. #macroData .. " ‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥", 5)
                else
                    notify("Save Failed", "Could not save macro", 5)
                end
            end
        end
    end
})

Tabs.Main:Space()

-- ‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏î‡πà‡∏≤‡∏ô
local function autoPlayOnStart()
    if playing and CurrentMacro and #macroData > 0 then
        task.spawn(function()
            -- ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°
            task.wait(2) -- ‡∏£‡∏≠‡πÅ‡∏Ñ‡πà 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡∏°‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
            
            -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
            while playing do
                for step = 1, #macroData do
                    if not playing then break end
                    
                    local action = macroData[step]
                    if action then
                        CurrentStep = step
                        TotalSteps = #macroData
                        StatusText = "Playing"
                        ActionText = action.ActionType or "Action"
                        UnitText = action.TowerName or action.AbilityName or "Auto"
                        WaitingText = ""
                        updateStatus()
                        
                        savePlaybackState(CurrentMacro, step)
                        
                        -- ‡∏£‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
                        local success = pcall(function()
                            executeAnyAction(action)
                        end)
                        
                        if not success then
                            print("[Macro] Step", step, "execution failed, but continuing...")
                        end
                    end
                    
                    if StepDelay > 0 then
                        task.wait(StepDelay)
                    else
                        task.wait(0.05) -- ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏•‡πà‡∏≤‡∏ä‡πâ‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
                    end
                end
                
                if seamlessMode and playing then
                    -- ‡∏£‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏î‡πà‡∏≤‡∏ô‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏•‡πà‡∏ô‡∏ã‡πâ‡∏≥
                    StatusText = "Waiting Next Round"
                    updateStatus()
                    repeat task.wait(1) until not playing or (RS:FindFirstChild("Wave") and RS.Wave.Value == 1)
                    task.wait(2)
                else
                    break
                end
            end
            
            -- ‡∏à‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô
            CurrentStep = 0
            StatusText = "Idle"
            ActionText = ""
            UnitText = ""
            WaitingText = ""
            clearPlaybackState()
            updateStatus()
            
            if playing then
                notify("Playback Finished", CurrentMacro, 3)
                playing = false
            end
        end)
    end
end

local playToggle = Tabs.Main:Toggle({
    Flag = "PlayMacro",
    Title = "‚ñ∂Ô∏è ‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥",
    Default = savedSettings.playMacroEnabled or false,
    Callback = function(v)
        playing = v
        saveSettings()
        if v then
            local mapMacroLoaded = false
            pcall(function()
                local gamemode = RS:FindFirstChild("Gamemode")
                local mapName = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("MapName")
                if gamemode and mapName then
                    local gm = gamemode.Value
                    local mn = mapName.Value
                    local key = gm .. "_" .. mn
                    if getgenv().MacroMaps[key] and getgenv().MacroMaps[key] ~= "--" and Macros[getgenv().MacroMaps[key]] then
                        CurrentMacro = getgenv().MacroMaps[key]
                        macroData = Macros[CurrentMacro] or {}
                        TotalSteps = #macroData
                        mapMacroLoaded = true
                        
                        task.spawn(function()
                            task.wait(0.2)
                            pcall(function()
                                macroDropdown:Select(CurrentMacro)
                            end)
                        end)
                        
                        notify("Map Macro Loaded", "Using " .. CurrentMacro .. " for " .. mn, 3)
                    end
                end
            end)
            
            if not CurrentMacro or #macroData == 0 then
                notify("Error", "No macro selected or macro is empty", 5)
                playing = false
                return
            end
            
            notify("‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏•‡πà‡∏ô", "‡πÄ‡∏•‡πà‡∏ô " .. #macroData .. " ‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥", 3)
            autoPlayOnStart()
        else
            StatusText = "Idle"
            WaitingText = ""
            ActionText = ""
            UnitText = ""
            clearPlaybackState()
            updateStatus()
        end
    end
})

Tabs.Main:Space()
Tabs.Main:Divider()
Tabs.Main:Space()

Tabs.Main:Paragraph({
    Title = "‚öôÔ∏è Playback Settings",
    Desc = "Configure playback behavior"
})

Tabs.Main:Space()

Tabs.Main:Input({
    Flag = "StepDelay",
    Title = "Step Delay (seconds)",
    Value = tostring(StepDelay),
    Placeholder = "0",
    Callback = function(v)
        StepDelay = tonumber(v) or 0
        saveSettings()
    end
})

Tabs.Main:Space()
Tabs.Main:Divider()
Tabs.Main:Space()

Tabs.Main:Paragraph({
    Title = "üìä Live Status",
    Desc = "Real-time information about macro recording and playback."
})

StatusLabel = Tabs.Main:Paragraph({ Title = "üìä Status: Idle", Desc = "" })
StepLabel = Tabs.Main:Paragraph({ Title = "üìù Step: 0/0", Desc = "" })
ActionLabel = Tabs.Main:Paragraph({ Title = "‚ö° Action: ", Desc = "" })
UnitLabel = Tabs.Main:Paragraph({ Title = "üóº Unit: ", Desc = "" })
WaitingLabel = Tabs.Main:Paragraph({ Title = "‚è≥ Waiting: ", Desc = "" })

Tabs.Maps:Paragraph({
    Title = "üó∫Ô∏è Dynamic Map Assignment",
    Desc = "Assign macros to specific maps - automatically updates based on gamemode!"
})

Tabs.Maps:Space()

local selectedGamemode = "Story"
local currentMapSection = nil

local function updateMapDisplay()
    if currentMapSection then
        pcall(function()
            currentMapSection:Destroy()
        end)
        currentMapSection = nil
    end
    
    task.wait(0.05)
    
    local maps = getMapsByGamemode(selectedGamemode)
    
    if #maps == 0 then
        currentMapSection = Tabs.Maps:Section({
            Title = "‚ö†Ô∏è No Maps Available",
            Opened = true,
        })
        currentMapSection:Paragraph({
            Title = "No Maps Found",
            Desc = "No maps available for " .. selectedGamemode
        })
        return
    end
    
    currentMapSection = Tabs.Maps:Section({
        Title = "üìç " .. selectedGamemode .. " Maps",
        Opened = true,
    })
    
    for _, mapName in ipairs(maps) do
        local key = selectedGamemode .. "_" .. mapName
        local currentMacro = getgenv().MacroMaps[key] or "--"
        
        local macroNames = getMacroNames()
        table.insert(macroNames, 1, "--")
        
        currentMapSection:Dropdown({
            Flag = "MacroFor_" .. key,
            Title = mapName,
            Values = macroNames,
            Value = currentMacro,
            Callback = function(value)
                if value ~= "--" then
                    getgenv().MacroMaps[key] = value
                    notify("Map Assignment", mapName .. " ‚Üí " .. value, 3)
                else
                    getgenv().MacroMaps[key] = nil
                    notify("Map Assignment", mapName .. " cleared", 3)
                end
                saveSettings()
            end,
            Searchable = true,
        })
    end
end

Tabs.Maps:Dropdown({
    Flag = "MacroGamemodeSelect",
    Title = "Select Gamemode",
    Values = {"Story", "Infinite", "Challenge", "LegendaryStages", "Raids", "Dungeon", "Survival", "ElementalCaverns", "Event", "MidnightHunt", "Portal", "BossRush", "Siege", "Breach"},
    Value = "Story",
    Callback = function(value)
        selectedGamemode = value
        task.spawn(function()
            updateMapDisplay()
        end)
    end,
})

Tabs.Maps:Space()
Tabs.Maps:Divider()
Tabs.Maps:Space()

task.spawn(function()
    task.wait(0.1)
    updateMapDisplay()
end)

task.spawn(function()
    task.wait(2)
    pcall(function()
        local gamemode = RS:FindFirstChild("Gamemode")
        local mapName = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("MapName")
        if gamemode and mapName then
            local gm = gamemode.Value
            local mn = mapName.Value
            local key = gm .. "_" .. mn
            if getgenv().MacroMaps[key] and getgenv().MacroMaps[key] ~= "--" and Macros[getgenv().MacroMaps[key]] then
                CurrentMacro = getgenv().MacroMaps[key]
                macroData = Macros[CurrentMacro] or {}
                TotalSteps = #macroData
                
                task.wait(0.3)
                if macroDropdown then
                    pcall(function()
                        macroDropdown:Select(CurrentMacro)
                    end)
                end
                
                notify("Auto-Selected", CurrentMacro .. " for " .. mn, 5)
            end
        end
    end)
end)

Tabs.Settings:Paragraph({
    Title = "‚öôÔ∏è Settings",
    Desc = "Manage your macros and UI settings."
})

Tabs.Settings:Space()

Tabs.Settings:Button({
    Title = "üîÑ Refresh Macro List",
    Callback = function()
        loadMacros()
        local newMacroNames = getMacroNames()
        if macroDropdown then
            pcall(function()
                macroDropdown:Refresh(newMacroNames)
            end)
        end
        notify("Refreshed", "Macro list updated", 3)
    end
})

Tabs.Settings:Button({
    Title = "üîÅ Clear Resume State",
    Callback = function()
        clearPlaybackState()
        resumeFromStep = 0
        notify("Cleared", "Resume state cleared - will start from beginning", 3)
    end
})

Tabs.Settings:Space()
Tabs.Settings:Divider()
Tabs.Settings:Space()

Tabs.Settings:Paragraph({
    Title = "üîÑ Seamless Mode",
    Desc = "Automatically restart macro when round ends"
})

Tabs.Settings:Space()

Tabs.Settings:Toggle({
    Flag = "SeamlessMode",
    Title = "Enable Seamless Mode",
    Default = seamlessMode,
    Callback = function(v)
        seamlessMode = v
        saveSettings()
        if v then
            notify("Seamless Mode", "Enabled - Macro will auto-restart", 3)
        else
            notify("Seamless Mode", "Disabled", 3)
        end
    end
})

Tabs.Settings:Toggle({
    Flag = "AutoReplayOnRestart",
    Title = "Auto Replay on Restart",
    Default = autoReplayOnRestart,
    Callback = function(v)
        autoReplayOnRestart = v
        saveSettings()
    end
})

Tabs.Settings:Space()
Tabs.Settings:Divider()
Tabs.Settings:Space()

Tabs.Settings:Button({
    Title = "üóëÔ∏è Unload UI",
    Callback = function()
        clearPlaybackState()
        pcall(function()
            if Window and Window.Destroy then
                Window:Destroy()
            end
        end)
        notify("Unloaded", "Macro System UI closed", 3)
    end
})

local towerMonitor = {}
local lastRecordedUpgrade = {}
local placementMonitor = {}

-- ‡∏£‡∏∞‡∏ö‡∏ö‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏ó‡∏∏‡∏Å Remote
local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt, false)

mt.__namecall = function(self, ...)
    local method, args = getnamecallmethod(), {...}
    local remoteName = tostring(self.Name or "")
    
    local result = old(self, ...)
    
    if recording then
        task.spawn(function()
            local success, err = pcall(function()
                local now = tick()
                
                -- ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ó‡∏∏‡∏Å Remote ‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
                local actionType = "RemoteCall"
                local towerName = "Auto"
                local abilityName = "Auto"
                
                -- ‡∏£‡∏∞‡∏ö‡∏∏‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥
                if remoteName:lower():find("place") or remoteName:lower():find("tower") then
                    actionType = "Place"
                    towerName = tostring(args[1] or "Unknown")
                elseif remoteName:lower():find("upgrade") then
                    actionType = "Upgrade"
                    -- ‡∏´‡∏≤‡∏ä‡∏∑‡πà‡∏≠‡∏´‡∏≠‡∏Ñ‡∏≠‡∏¢‡∏à‡∏≤‡∏Å argument
                    if args[1] and typeof(args[1]) == "Instance" then
                        towerName = args[1].Name
                    end
                elseif remoteName:lower():find("abilityselection") then
                    actionType = "SelectAbility"
                    abilityName = tostring(args[2] or "Unknown")
                    
                    -- ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏Å‡∏¥‡∏•
                    abilityDataCache.lastSelectedAbility = {
                        id = args[1],
                        name = args[2],
                        time = now
                    }
                elseif remoteName:lower():find("ability") and not remoteName:lower():find("selection") then
                    actionType = "UseAbility"
                    if args[1] and typeof(args[1]) == "Instance" then
                        towerName = args[1].Name
                    end
                    -- ‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏Å‡∏¥‡∏•‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ
                    if abilityDataCache.lastSelectedAbility then
                        abilityName = abilityDataCache.lastSelectedAbility.name
                    end
                end
                
                -- ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥
                local savedArgs = {}
                for i, arg in ipairs(args) do
                    if typeof(arg) == "CFrame" then
                        savedArgs[i] = {arg:GetComponents()}
                    else
                        savedArgs[i] = arg
                    end
                end
                
                table.insert(macroData, {
                    RemoteName = remoteName,
                    Args = savedArgs,
                    Time = now,
                    IsInvoke = (method == "InvokeServer"),
                    Cost = 0,
                    TowerName = towerName,
                    ActionType = actionType,
                    AbilityName = abilityName
                })
                
                -- ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
                StatusText = "Recording"
                CurrentStep = #macroData
                TotalSteps = #macroData
                ActionText = actionType
                UnitText = towerName ~= "Auto" and towerName or abilityName
                WaitingText = ""
                updateStatus()
                
                print("[Macro] ‚úì Recorded:", actionType, "-", towerName, "-", abilityName, "[Total:", #macroData .. "]")
            end)
            
            if not success then
                warn("[Macro] Recording error:", err)
            end
        end)
    end
    
    return result
end

setreadonly(mt, true)

-- ‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡∏£‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
task.spawn(function()
    while true do
        task.wait(3)
        local now = tick()
        for key, _ in pairs(placementMonitor) do
            if placementMonitor[key] and (now - placementMonitor[key]) > 5 then
                placementMonitor[key] = nil
            end
        end
        for key, time in pairs(lastRecordedUpgrade) do
            if (now - time) > 5 then
                lastRecordedUpgrade[key] = nil
            end
        end
    end
end)

notify("üé¨ Macro System", "‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡πà‡∏ô‡∏ó‡∏∏‡∏Å‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥", 5)
print("[Macro System] Loaded successfully!")
